# Copyright (c) 2018, MD2K Center of Excellence
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from cerebralcortex.core.datatypes.datastream import DataStream
from cerebralcortex.core.datatypes.datastream import DataPoint
from cerebralcortex.core.datatypes.stream_types import StreamTypes
from core.computefeature import ComputeFeatureBase

import datetime
import json
import uuid
from typing import List

feature_class_name = 'PhoneAppusageFeatures'

app_usage_all_context_per_hour = 'org.md2k.data_analysis.feature.phone.app_usage.all_context.per_hour'
app_usage_all_context_total =\
'org.md2k.data_analysis.feature.phone.app_usage.all_context.total' 
app_usage_home_per_hour =\
'org.md2k.data_analysis.feature.phone.app_usage.home.per_hour'
app_usage_home_total =\
'org.md2k.data_analysis.feature.phone.app_usage.home.total' 
app_usage_outside_per_hour  =\
'org.md2k.data_analysis.feature.phone.app_usage.outside.per_hour'
app_usage_outside_total  =\
'org.md2k.data_analysis.feature.phone.app_usage.outside.total'
app_usage_work_per_hour =\
'org.md2k.data_analysis.feature.phone.app_usage.work.per_hour'
app_usage_work_total =\
'org.md2k.data_analysis.feature.phone.app_usage.work.total'
app_usage_interval =\
'org.md2k.data_analysis.feature.phone.app_usage_interval'




class PhoneAppusageFeatures(ComputeFeatureBase):
    """
    This class splits the DataPoints containing a dict as the sample that were generated by phone_features to 
    individual data points containing basic data type like float, string, etc,.
    """
    def split_app_usage(self, stream_name, user_id, day, metadata_name):
        """
        For the given stream name, get the computed streams for the given user
        split the complex DataPoint containing a dict, create new streams
        store back with DataPoints having samples containing primitive data
        types.

        :param str stream_name: The stream containing the computed feature
        :param str user_id: UUID of the user
        :param str day: day on which to retrieve the computed values
        :param str metadata_name: file name containing the template of the metadata
        :return: None
        """
        stream_ids = self.get_latest_stream_id(user_id, stream_name)
        split_dps = {}
        for stream_id in stream_ids:
            ds = self.CC.get_stream(stream_id['identifier'], user_id, day)
            for dp in ds.data:
                for appcat in dp.sample:
                    formatted_name = appcat.replace(' ','')
                    formatted_name = formatted_name.replace('&','_')
                    if formatted_name not in split_dps:
                        split_dps[formatted_name] =\
                        DataPoint(sample=dp.sample[appcat],
                                 start_time=dp.start_time,
                                 end_time=dp.end_time,
                                 offset=dp.offset)
                    else:
                        tmpdp = split_dps[formatted_name]
                        tmpdp.sample += dp.sample[appcat]



            
        input_streams_metadata = []
        for input_strm in stream_ids:
            if type(input_strm) != dict:
                self.CC.logging.log('Inconsistent type found in '
                                    'input_streams, cannot store given stream',str(input_streams))
                return

            stream_info = {}
            stream_info['identifier'] = input_strm['identifier']
            stream_info['name'] = stream_name
            input_streams_metadata.append(stream_info)
            
        metadata_file_path =\
        '/'.join(['core','resources','metadata',metadata_name])
        metadata_str = str(__loader__.get_data(metadata_file_path).decode("utf-8"))

        metadata = json.loads(metadata_str)
        
        stream_str = str(metadata_file_path) 
        stream_str += str(user_id) 
        stream_str += str(self.__class__.__name__)
        stream_str += str(metadata)
        stream_name = metadata['name']
        
        metadata["execution_context"]["processing_module"]["input_streams"]\
                = input_streams_metadata

        for appcat in split_dps:
            new_stream_name =\
            stream_name.replace('phone.app_usage.','phone.app_usage.%s.' %
                                (appcat))
            
            stream_str += str(new_stream_name)

            output_stream_id = str(uuid.uuid3(uuid.NAMESPACE_DNS, stream_str))

            self.store(identifier=output_stream_id, owner=user_id, name=new_stream_name,
                   data_descriptor=metadata["data_descriptor"],
                   execution_context=metadata["execution_context"], annotations=metadata["annotations"],
                   stream_type=StreamTypes.DATASTREAM, data=[split_dps[appcat]],
                   localtime=True)


    def process(self, user_id: str, all_days: List[str]):
        """
        Main processing function inherited from ComputerFeatureBase

        :param str user_id: UUID of the user
        :param List(str) all_days: List of days with format 'YYYYMMDD'
        :return:
        """
        if self.CC is None:
            return

        self.CC.logging.log("Processing "
                            "PhoneAppusageFeatures %s %s %s" %
                            (str(datetime.datetime.now), str(user_id),
                             str(all_days)))
        stream_ids = self.get_latest_stream_id(user_id,
                                          app_usage_interval)
        for day in all_days:
            print('-'*20,day,'-'*20)
            split_dp = []
            for stream_id in stream_ids:
                ds = self.CC.get_stream(stream_id['identifier'], user_id, day)

                for dp in ds.data:
                    for app in dp.sample:
                        for interval in dp.sample[app]:
                            dpsplit = DataPoint(start_time=interval['start_time'],
                                      end_time=interval['end_time'],
                                      offset=0,
                                      sample=str(app))
                            split_dp.append(dpsplit)

                for strm in stream_ids:
                    strm['name'] = app_usage_interval
                self.store_stream(filepath="app_usage_intervals.json",
                                  input_streams=stream_ids, user_id=user_id,
                                  data=split_dp, localtime=False)


            self.split_app_usage(app_usage_all_context_total, user_id,
                                 day, 'app_category_usage_total.json')
            self.split_app_usage(app_usage_all_context_per_hour, user_id,
                                 day,
                                 'appusage_duration_average_by_category_split.json')
            self.split_app_usage(app_usage_home_per_hour, user_id,
                                 day,
                                 'appusage_duration_average_by_category_home_split.json')
            self.split_app_usage(app_usage_home_total, user_id,
                                 day,
                                 'appusage_duration_total_by_category_home_split.json')
            self.split_app_usage(app_usage_outside_per_hour, user_id,
                                 day,
                                 'appusage_duration_average_by_category_outside_split.json')
            self.split_app_usage(app_usage_outside_total, user_id,
                                 day,
                                 'appusage_duration_total_by_category_outside_split.json')
            self.split_app_usage(app_usage_work_per_hour, user_id,
                                 day,
                                 'appusage_duration_average_by_category_work_split.json')
            self.split_app_usage(app_usage_work_total, user_id,
                                 day,
                                 'appusage_duration_total_by_category_work_split.json')
